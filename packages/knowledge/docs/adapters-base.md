---
type: Documentation
domain: knowledge
origin: packages/knowledge/generation/adapters/base.py
last_modified: 2026-01-31
generated: true
source: packages/knowledge/generation/adapters/base.py
generated_at: 2026-01-31T08:54:43.604697
hash: 08dc52069e4b5afdbe50fa7d005e2706291f518aebe606d8763794075205d917
---

## Documentation Generation Adapters: Base Class Documentation

This document details the base adapter class for documentation generation. It serves as an interface for language-specific adapters, defining the core methods required to process source code files and prepare them for documentation creation using Large Language Models (LLMs).

**Module Purpose:**

The primary responsibility of this module is to establish a consistent structure for integrating different programming languages into the documentation generation pipeline. By defining an abstract base class, we ensure that each language adapter adheres to a common set of methods, simplifying the overall system design and promoting extensibility.

**Key Classes:**

* **`BaseAdapter`:** This is an abstract base class (ABC) that defines the interface for all documentation adapters. It cannot be instantiated directly. Instead, concrete adapter classes must inherit from `BaseAdapter` and implement its abstract methods. The class uses abstract methods to enforce a specific contract for handling files, parsing content, and generating prompts.

**Important Functions:**

* **`can_handle(file_path: Path) -> bool`:** This abstract method determines whether a specific adapter is capable of processing a given file based on its path. You must implement this method in each adapter to check file extensions, content type, or other relevant criteria. It returns `True` if the adapter can handle the file, and `False` otherwise.

* **`parse(file_path: Path, content: str) -> List[str]`:** This abstract method is responsible for parsing the content of a source code file and breaking it down into smaller, manageable chunks. These chunks are designed to be suitable for processing by an LLM, respecting token limits and maintaining context. The method accepts the file path and the raw file content as input and returns a list of strings, where each string represents a single chunk.

* **`get_prompt(file_path: Path, parsed_content: str) -> str`:** This abstract method generates the prompt that will be sent to the LLM for documentation generation. It takes the file path and a single parsed content chunk as input. The prompt should be carefully crafted to instruct the LLM to generate appropriate documentation for the given code snippet. It returns a string containing the complete prompt.

* **`post_process(file_path: Path, outputs: List[str]) -> str`:** This method combines the individual documentation outputs generated by the LLM for each chunk of code. It provides a default implementation that simply joins the outputs with double newlines, but you can override this method in specific adapters to implement more sophisticated post-processing logic, such as reordering sections or adding introductory/concluding remarks. It accepts the file path and a list of LLM outputs and returns a single string containing the final documentation.

**Type Hints:**

The code extensively uses type hints (e.g., `file_path: Path`, `content: str`, `-> bool`) to improve code readability and maintainability. These hints specify the expected data types for function arguments and return values, enabling static analysis tools to detect potential errors and providing better code completion in IDEs. The `Path` type from the `pathlib` module is used to represent file paths in a platform-independent manner.

**Design Decisions and Patterns:**

* **Abstract Base Class:** The use of an abstract base class enforces a consistent interface for all adapters, promoting code reuse and simplifying integration.
* **Separation of Concerns:** Each adapter is responsible for handling a specific language, keeping the core documentation generation logic independent of language-specific details.
* **Chunking:** The `parse` method allows for breaking down large files into smaller chunks, which is essential for working with LLMs that have token limits.
* **Prompt Engineering:** The `get_prompt` method provides a dedicated interface for crafting effective prompts for the LLM, allowing for fine-tuning of the documentation generation process.