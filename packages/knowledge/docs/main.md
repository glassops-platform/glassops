---
type: Documentation
domain: knowledge
origin: packages/knowledge/main.py
last_modified: 2026-02-01
generated: true
source: packages/knowledge/main.py
generated_at: 2026-02-01T19:35:34.645798
hash: 11c84f152af5919603a1faa11b95ec8eb3bfd840332ca9614c74bddd3bec3cf6
---

## GlassOps Knowledge Pipeline Documentation

This document describes the GlassOps Knowledge Pipeline, a system designed to manage and query documentation from various sources. The pipeline automates the process of discovering, embedding, indexing, and querying documentation, enabling Retrieval-Augmented Generation (RAG) for informed responses.

**Module Purpose:**

The `knowledge` package provides a complete solution for building and interacting with a knowledge base. It handles ingestion of documentation, creation of vector embeddings, storage and indexing of those embeddings, detection of semantic drift in the documentation, and querying the knowledge base to provide answers to user questions. It also includes functionality for automatically generating documentation from source code.

**Key Classes and Roles:**

*   **`Generator`**: This class is responsible for generating documentation from source code files. It takes a root directory as input and processes files matching specified patterns.
*   Other classes are primarily functions within modules, but represent core components:
    *   `discover_and_chunk_docs`: Handles the discovery and splitting of documentation into manageable chunks.
    *   `get_embeddings_for_docs`: Computes vector embeddings for the documentation chunks.
    *   `build_or_update_index`: Creates or updates the vector store index.
    *   `detect_drift`: Identifies documentation that has undergone significant semantic changes.
    *   `query_index`: Executes queries against the vector store and returns relevant results.

**Important Functions and Their Behavior:**

*   **`run_generate(patterns: list[str]) -> None`**: This function initiates the documentation generation process. It takes a list of file patterns (globs) as input, instantiates a `Generator` object, and runs the generation process. The patterns define which files should be processed for documentation.
*   **`run_pipeline()`**: This is the main function that orchestrates the entire knowledge pipeline. It parses command-line arguments, performs the necessary steps (documentation discovery, embedding generation, indexing, drift detection, and querying), and prints the results.
*   **`discover_and_chunk_docs() -> list`**: This function discovers documentation files from various sources and splits them into smaller chunks suitable for embedding. The return value is a list of document chunks.
*   **`get_embeddings_for_docs(docs: list, batch_size: int) -> list`**: This function takes a list of document chunks and generates vector embeddings for each chunk. It uses a router to select an embedding model (Gemini as primary, Gemma as fallback). The `batch_size` parameter controls the number of documents processed in each batch. The return value is a list of embeddings.
*   **`build_or_update_index(embeddings: list) -> None`**: This function builds or updates the vector store index with the provided embeddings. It ensures that the knowledge base is up-to-date with the latest documentation.
*   **`detect_drift(embeddings: list, threshold: float) -> list`**: This function detects semantic drift in the documentation by comparing the current embeddings to a baseline. It returns a list of documents that have drifted beyond the specified `threshold`.
*   **`query_index(query: str) -> str`**: This function takes a user query as input and retrieves relevant information from the vector store. It returns the answer generated by the RAG process.

**Type Hints and Their Significance:**

The code extensively uses type hints (e.g., `patterns: list[str]`, `batch_size: int`, `-> None`, `-> list`). These hints improve code readability, maintainability, and help catch potential errors during development. They clearly define the expected data types for function arguments and return values.

**Notable Patterns and Design Decisions:**

*   **Configuration Management:** The pipeline loads configuration parameters from a `config.json` file, allowing for easy customization of settings such as batch size and drift threshold. It also supports loading environment variables from a `.env` file.
*   **Command-Line Interface:** The `argparse` module is used to create a command-line interface, enabling users to interact with the pipeline through various options (e.g., running a query, forcing re-indexing, generating documentation).
*   **Modular Design:** The pipeline is structured into separate modules for ingestion, embedding, indexing, drift detection, and querying, promoting code reusability and maintainability.
*   **Embedding Router/Fallback:** The `get_embeddings_for_docs` function uses a router to select an embedding model, with Gemini as the primary choice and Gemma as a fallback. This provides resilience in case the primary model is unavailable.
*   **Semantic Drift Detection:** The inclusion of semantic drift detection helps ensure that the knowledge base remains accurate and up-to-date by identifying documentation that has changed significantly.
*   **Documentation Generation:** The pipeline can automatically generate documentation from source code, reducing the manual effort required to keep the knowledge base current.