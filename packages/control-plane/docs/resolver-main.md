---
type: Documentation
domain: control-plane
origin: packages/control-plane/cmd/resolver/main.go
last_modified: 2026-01-31
generated: true
source: packages/control-plane/cmd/resolver/main.go
generated_at: 2026-01-31T09:46:02.544899
hash: e53a85af9c11df19f7caa52717a03e4fe1f512958c414471e02e77ad2ada38bc
---

## GlassOps Control Plane Resolver Documentation

This document describes the functionality of the GlassOps Control Plane Resolver, a command-line tool responsible for validating deployments against defined policies. It acts as a gatekeeper, ensuring deployments adhere to quality and architectural standards before proceeding.

**Package Purpose and Responsibilities**

The `main` package implements the core logic for the resolver. Its primary responsibility is to read a deployment contract generated by the runtime environment, resolve a relevant policy, and then enforce the rules defined within that policy against the contract data. If the deployment does not meet the policy requirements, the resolver blocks further progress.

**Key Types and Interfaces**

*   `contract.DeploymentContract`: This type, defined in the `github.com/glassops-platform/glassops-control-plane/internal/contract` package, represents the state of a deployment as reported by the runtime. It contains information about code coverage, static analysis results, and other quality metrics.
*   `policy.EffectivePolicy`: This type, defined in the `github.com/glassops-platform/glassops-control-plane/internal/policy` package, represents the resolved policy against which the deployment will be evaluated. It includes governance rules such as minimum code coverage and static analysis requirements.

**Important Functions and Their Behavior**

*   `main()`: This is the entry point of the resolver. It performs the following steps:
    1.  **Loads the Deployment Contract:** Reads the deployment contract from the file `.glassops/deployment-contract.json`. If the file is not found, the program exits with a fatal error.
    2.  **Resolves the Policy:** Calls the `policy.ResolvePolicy()` function to obtain the effective policy. In this example, it uses "devops-config.json" as the policy source and an 80.0 threshold.
    3.  **Enforces Quality Gates:**
        *   **Coverage Check:** Compares the actual code coverage reported in the deployment contract (`dc.Quality.Coverage.Actual`) against the minimum coverage required by the policy (`effPolicy.Governance.MinCoverage`). If the actual coverage is below the required minimum, the program prints an error message and exits with a non-zero exit code (1).
        *   **Static Analysis Check:** Checks if static analysis is enabled in the policy (`effPolicy.Governance.StaticAnalysis.Enabled`) and if the deployment contract indicates that static analysis passed (`dc.Quality.StaticAnalysis.Met`). If static analysis is enabled and has not passed, the program prints an error message indicating the tool used for static analysis and exits with a non-zero exit code (1).
    4.  **Success:** If all checks pass, the program prints a success message indicating that the deployment meets the policy requirements.

**Error Handling Patterns**

The resolver employs a straightforward error handling approach. Critical errors, such as the inability to read the deployment contract, are handled using `log.Fatalf()`, which prints an error message to the console and terminates the program. Other errors, such as those potentially returned by `policy.ResolvePolicy()`, are currently ignored for simplicity, but should be handled more robustly in a production environment.

**Concurrency Patterns**

This version of the resolver does not employ any concurrency patterns (goroutines or channels). It operates as a single-threaded process.

**Notable Design Decisions**

*   **Policy Resolution:** The `policy.ResolvePolicy()` function abstracts the process of loading and interpreting policies. This allows for flexibility in how policies are defined and managed.
*   **Contract-Based Governance:** The use of a deployment contract provides a standardized way for the runtime environment to communicate the state of a deployment to the control plane.
*   **Gatekeeper Approach:** The resolver acts as a gatekeeper, preventing deployments that do not meet the defined quality and architectural standards from proceeding.
*   **Exit Codes:** The use of non-zero exit codes (specifically 1) signals failure to calling processes, allowing for integration into CI/CD pipelines.

**Usage Instructions**

You must ensure that a file named `.glassops/deployment-contract.json` exists in the current directory, containing a valid `DeploymentContract` as defined by the `contract` package. You also need a policy file named `devops-config.json` for the policy resolution. The resolver will then evaluate the deployment against the policy and report whether it passes or fails.